# 自用运维面试题

作者：C_Joe

请善用 Ctrl + F 或查找功能，对内容进行快速定位。

[TOC]

## 资料参考链接

1. [OSI 7层模型和TCP/IP 4层模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/32059190)
2. [两张动图-彻底明白TCP的三次握手与四次挥手_三次握手和四次挥手_小书go的博客-CSDN博客](https://blog.csdn.net/qzcsu/article/details/72861891)
3. [云计算的三种服务模式：IaaS，PaaS和SaaS - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/28532380)
4. [C-Joe1/learn-by-myself: C_Joe的自学笔记 (github.com)](https://github.com/C-Joe1/learn-by-myself)
5. [nginx负载均衡的五种算法_nginx负载均衡算法_皓阳当空的博客-CSDN博客](https://blog.csdn.net/apple9005/article/details/79961391)
6. [Nginx面试题（总结最全面的面试题！！！） - 掘金 (juejin.cn)](https://juejin.cn/post/6844904125784653837#heading-4)
7. [彻底搞懂 MySQL 事务的隔离级别-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/743691)
8. [四个案例看懂 MySQL 事务隔离级别-mysql四种事务隔离级别 (51cto.com)](https://www.51cto.com/article/679914.html)
9. [MySQL 事务的四大特性以及隔离级别 | Laravel China 社区 (learnku.com)](https://learnku.com/articles/45573)
10. [面试必问的 MySQL，你懂了吗？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/584739919)
11. [一张图彻底搞懂 MySQL 的锁机制[面试题]-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1822612)
12. [一张图彻底搞懂 MySQL 的锁机制更新一\] (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI4NzE2MDI5NA==&mid=2650282425&idx=1&sn=ce82fb6ff61657e9c8253a49c5e905ab&chksm=f3dd5b30c4aad226e1b0bdaaf28ddb31256eef2559d13078d52ca2dd80011d36fa850ff71461&scene=21#wechat_redirect)
13. [主数据库宕机怎么办？MHA高可用帮你实现主从服务器自动切换（详细操作与命令详解）_数据库服务器崩溃自动切换_小肥是只猫的博客-CSDN博客](https://blog.csdn.net/qq_41786285/article/details/109375970)
14. [MYSQL高可用架构之MHA实战三 mha+keepalive_ZeroMaster的博客-CSDN博客](https://blog.csdn.net/wszhm123/article/details/126784759)
15. [MHA master_ip_failover脚本文件,自用亲测，无坑_ 清欢渡.的博客-CSDN博客](https://blog.csdn.net/shm19990131/article/details/107423239)
16. [Linux实战教学笔记40： Mha-Atlas-MySQL高可用方案实践(二) - 无情站长 - 博客园 (cnblogs.com)](https://www.cnblogs.com/skyhu365/p/10652830.html#_label2_0)
17. [Redis 常见面试题 | 小林coding (xiaolincoding.com)](https://www.xiaolincoding.com/redis/base/redis_interview.html#aof-日志是如何实现的)
18. [Redis 事务详解 - JavaKeeper - SegmentFault 思否](https://segmentfault.com/a/1190000023951592)

## 网络基础

### OSI 模型

#### **七层模型**

应用层 => 表示层 => 会话层 => 传输层 => 网络层 => 数据链路层 => 物理层

#### **四层模型**

（			  应用层		 	  ）=> 传输层 => 网络层 => （  	数据链路层  	）

#### 模型讲解

1. **应用层**：为应用程序提供网络接口；

2. **表示层**：将数据格式化转换，进行加密、解密、压缩；

3. **会话层**：用于建立、维护及管理会话连接；

4. **传输层**：用于建立、维护及管理端到端连接（报文传输与差错控制）；

5. **网络层**：提供路由寻址（IP 协议），将上层分段的数据打包，从源端传输到目标端（网络互联）；

6. **数据链路层**：将数据包封装为 MAC 帧，提供节点到节点的数据传输，控制网络层与物理层之间的通信；
   1. MAC 帧分为两部分：
      1. Head：标明数据发送者、接收者、数据类型；
      2. Data：实际数据内容。
   
   2. 通过 MAC 地址（网卡地址）定位数据包路径：
   
7. **物理层**：在介质中传输比特流数据，提供底层的链路介质规范。
   1. 通过光缆、电缆、无线电波等方式将设备连接起来组网；
   2. 两个不同局域网（移动、电信）通信，需要ISP互联网服务供应商的物理连接。

![1](https://note-1308251438.cos.ap-guangzhou.myqcloud.com/typora/202208191147064.gif)

### TCP 三次握手四次挥手（数据传输原理）

1. 三次握手：

   1. 客户端发送请求报文到服务端，表示需要建立 TCP 连接；

   2. 服务端将回复此请求报文到客户端，表示已收到建立 TCP 连接请求；

   3. 客户端在收到回复后，会再次回复请求报文到服务端，表示已收到回复，确定两端收发包正常，开始传输数据。

![image.png](https://s2.loli.net/2023/06/29/GjOE3BiNTSqVhWf.png)

2. 四次挥手：

   1. 客户端发送结束请求到服务端，表示需要结束 TCP 连接，

      此时客户端进入半关闭状态 Fin-wait1 ，客户端将不再发送数据，仅接收数据；

   2. 服务端将回复此请求，向客户端确定已收到结束请求，

      客户端收到确定信息回复后，进入等待状态 Fin-wait2 ；

   3. 待服务端传输数据完毕后，将向客户端发送结束请求，表示数据传输完毕，需结束 TCP 连接，

      此时服务端进入最后确认状态 Last-ACK ，等待客户端确认；

   4. 客户端将回复此请求，向服务端确认已收到结束请求，进入最终等待状态 Time-Wait ，

      客户端将在 2*<font color=red>MSL</font>（最长报文段寿命）后，进入结束状态 Closed ，不再收发数据，

      服务端收到确认信息后，进入结束状态 Closed ，不再收发数据。

![image.png](https://s2.loli.net/2023/06/29/gbMcZdkX7fmTPC8.png)

**关于 MSL **

用于保证第四次挥手时，客户端可以在 Time-Wait 时收到因确认信息丢失而导致服务端重发的结束请求，并重新进行第四次挥手。

MSL 并无固定值，TCP 协议允许不同的实现可以设置不同的 MSL 值。

## 云计算服务模式

**IaaS，PaaS 和 SaaS**

1. **IaaS : Infrastructure-as-a-Service（基础设施即服务）**

   将硬件外包到 IaaS 公司，IaaS 公司会提供云服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。

2. **PaaS : Platform-as-a-Service（平台即服务）**

   将一个开发平台作为服务提供给用户，PaaS 公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，让工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。

3. **SaaS: Software-as-a-Service（软件即服务）**

   将应用作为服务提供给客户，通过网页浏览器来接入，任何一个远程服务器上的应用都可以通过网络来运行。

<h1>Web服务</h1>

## Nginx

### Nginx 是什么

Nginx 是一个轻量级/高性能的反向代理 Web 服务器，同时也是一个比较优秀的负载均衡服务器和缓存服务器，它能实现非常高效的反向代理、负载平衡，它可以处理 2-3 万并发连接数，官方监测能支持 5 万并发，现在中国使用 nginx 网站用户有很多，例如：新浪、网易、 腾讯等。

### 为什么用 Nginx

跨平台、配置简单；

反向代理：可以不暴露正式的服务器IP地址；

高并发连接：处理2-3万并发连接数，官方监测能支持5万并发；

内存消耗小：开启10个nginx才占150M内存 ，nginx处理静态文件好，耗费内存少。

### Nginx 有高性能的原因

因为它的事件处理机制：异步非阻塞事件处理机制，运用了 epoll 模型，提供了一个队列，排队解决。

### Nginx的缺点

动态处理差，需要配合Tomcat进行动静分离处理。

### 动静分离怎么实现（思路）

对于静态资源比如图片，js，css等文件，我们则在反向代理服务器nginx中进行缓存，

这样浏览器在请求一个静态资源时，代理服务器nginx就可以直接处理，无需将请求转发给后端服务器tomcat；

若用户请求的动态文件，比如servlet,jsp则反向代理转发给Tomcat服务器处理，从而实现动静分离。

### Nginx 怎么处理请求

nginx接收一个请求后，首先由listen和server_name指令匹配server模块，再匹配server模块里的location，location就是实际地址。

```
server {            		    			# 第一个Server区块开始，表示一个独立的虚拟主机站点
    listen       80;      		        	# 提供服务的端口，默认80
    server_name  localhost;    				# 提供服务的域名主机名
    location / {							# 第一个location区块开始
        root   html;       					# 站点的根目录，相当于Nginx的安装目录
        index  index.html index.htm;		# 默认的首页文件，多个用空格分开
    }										# 第一个location区块结果
}       
```

### 什么是正向代理和反向代理

1. 正向代理就是一个人发送一个请求直接就到达了目标的服务器；
2. 反方代理就是请求统一被 Nginx 接收，nginx 反向代理服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。

### 负载均衡算法

1. **轮询（默认）**

   每个请求按时间顺序依次分配到不同的后端服务器，

   后端服务器宕机时，能被自动剔除，且请求响应情况不会受到任何影响；

2. **轮询权值**（weight）

   指定轮询概率，权重和访问比率成正比，用于后端服务器性能不均的情况，

   权重越高，被访问的概率就越大，常用于服务上线发布场景；

3. **基于IP地址计算的哈希值分配**（ip_hash）

   每个请求按访问IP生成的hash结果分配，会让相同客户端IP请求相同的服务器，

   可以有效解决动态网页存在的session共享问题；

4. **基于URL地址计算的哈希值分配**（url_hash）

   根据访问的URL计算出的hash结果来分配请求，每个请求的URL会指向后端某个固定的服务器，

   通常用在nginx作为静态资源（缓存）服务器的场景，可以提高缓存效率，
   但是nginx服务默认不支持该算法，如需要使用，要安装hash软件包；

5. **智能分配**（fair）

   通过智能识别后端服务器处理请求的响应时间来进行负载分配，响应时间短的优先分配，
   但是nginx服务默认不支持该算法，如需要使用，要安装upstream_fair模块；

<h1>数据库</h1>

## SQL 语句

[SQL Mind Map](https://github.com/C-Joe1/learn-by-myself/blob/main/SQL/SQL.png)

## MySQL

### 简述一下事务的几种特性

***简称 ACID，缺一不可。***

- **原子性（Atomicity）**

   一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。

  事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。

- **一致性（Consistency）**

  在事务开始之前和事务结束以后，数据库的完整性没有被破坏。

  这表示写入的数据必须完全符合所有的预设规则，这包含数据的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

- **隔离性（Isolation）**

  数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

- **持久性（Durability）**

  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 事务的隔离级别有哪些

隔离级别：用于在多个事务并发时进行事务隔离。

- **读未提交** (RU) READ UNCOMMITTED

  ***提供了事务之间最小限度的隔离。***

  - 容易出现脏读、幻读或不可重复读
  - 会读到其他事务未提交的数据

- **读已提交** (RC) READ COMMITT

  ***安全性比可重复读要低***

  - 不会出现脏读，但仍可能出现幻读或不可重复读
  - 会读到其他事务已提交的数据

- **可重复读** (RR) REPEATABLE READ

  ***MySQL的默认隔离级别***

  - 不会出现脏读、不可重复读，但仍可能出现幻读
  - 当前事务只能在其他事务已提交数据，且当前事务同样提交数据后，才能读取到数据

- **串行化** SERIALIZABLE

  ***性能最差的隔离级别***

  - 不会出现脏读、幻读以及不可重复读
  - 在上一个事务完成提交之前，其他事务无法进行操作

随着隔离级别的上调，事务性能会变得越来越差。

#### 知识补充

- **脏读**
  - 指当前事务读到了其他事务**未提交**的数据。
  - 未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。
  - 读到了并不一定最终存在的数据，这就是脏读。

- **可重复读**
  - 指在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。
  - 通常针对数据更新（UPDATE）操作。

- **不可重复读**
  - 指在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。
  - 通常针对数据更新（UPDATE）操作。

- **幻读**
  - 指当前事务修改数据后，被其他事务插入了与当前事务修改前相同的数据，并且其他事务比当前事务更快地提交了，造成当前事务无法查询到刚刚修改的数据。
  - 就像出现了幻觉一样，这就叫幻读。
  - 通常针对数据插入（INSERT）操作。

### 几种日志的作用

1. **错误日志（error log）**

   记录出错信息，也记录一些警告信息或者正确的信息。

2. **查询日志（general log）**

   记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。

3. **慢查询日志（slow query log）**

   设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。

4. **二进制日志（binlog）**

   记录对数据库执行更改的所有操作。

5. **中继日志（relay log）**

   中继日志也是二进制日志，用来给从库恢复。

6. **重做日志（redo log）**

   确保事务的持久性，防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

7. **回滚日志（undo log）**

   保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即可重复读。

### 锁机制有哪几种

对于不同引擎，MyISAM支持表锁，InnoDB支持行锁、也支持表锁。

| 粒度 | 使用方式       | 思想   |
| ---- | -------------- | ------ |
| 表锁 | 共享锁（读锁） | 乐观锁 |
| 页锁 | 排它锁（写锁） | 悲观锁 |
| 行锁 |                |        |

#### 知识补充 #未优化

1. **悲观锁**

   是每次在读数据时，都会给数据加上锁，避免其他的读操作拿到锁。

   每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据都会block直到它拿到锁。因此，悲观锁需要耗时比较的多，跟乐观锁比较，悲观锁是有数据库自己实现的，用的时候我们直接调用数据的相关语句就可以悲观锁涉及到的另外两个锁，他们是共享锁和排他锁，共享锁和排他锁时悲观锁的不同的实现，属于悲观锁的范畴。

2. **乐观锁**

   是给数据添加一个版本号，通过对比版本号来实现数据前后一致性的对比。

   所谓的数据版本，为数据增加一个版本号的字段，一般是通过为数据表增加一个数据类型的version字段实现，当读取数据时，将把二十年字段的值一同读取出来，数据每次更新都需要对version值加一，在我们提交更新的时候，判断数据表对应记录的当前版本信息与第一次取出来的version值进行对比，如果数据库的表当前版本号鱼取出来的version值相等，则给与更新否则认为过期数据不给与更新。

   乐观锁虽然叫锁其实在使用的时候是没有加锁，所以执行性能高。缺点：会产生ABA的问题，ABA问题指的是有一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到他的值还是为A值，会误认为没有被修改做为正常的执行修改操作，实际上这段时间他的值可能被修改为其他值，之后又被修改为A值。

### 如何理解MyISAM下的锁竞争

MyISAM存储引擎会优先处理写请求，因为MyISAM中认为写请求比读请求重要。假如大量的读写请求过来，就会导致读请求长时间的等待，或者"线程饿死"，因此MyISAM不适合运用于大量读写操作的场景。

可以通过设置low-priority-updates参数，设置请求链接的优先级，使MySQL优先处理读请求。

### InnoDB支持哪些锁类型 #未优化

1. InnoDB支持表锁、行级锁、单列索引、Gap Lock（间隙锁）、Next-key Lock锁。
2. 默认情况下，MySQL是使用的行锁。
3. 当在可重复读的情况下，MySQL的锁是建立在索引列的，如果没有索引列，则走的是表锁。
4. 间隙锁在事务中做范围查询时，会将指定的范围加锁。
5. Next-key Lock是位于单列索引和间隙锁之间，它会将指定的行进行加锁，并且会对指定行的两边加间隙锁。

### 如何监控MySQL中的锁情况

1. 使用show full processlist命令。
2. show engine innodb status命令。
3. 通过查看MySQL自带数据库infomation-schema中的INNODB_TRX、INNODB_LOCKS和INNODB_LOCK_WAITS表。

### 如何避免死锁 #未优化

1. 为了在单个innodb表上执行多个并发写入操作时避免死锁，可以在事务开始时，通过为预期要修改行，使用select …for update语句来获取必要的锁，即使这些行的更改语句是在之后才执行的在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时在申请排他锁。因为这时候当用户在申请排他锁时，其他事务可能又已经获得了相同记录的共享锁。
2. 如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发获取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。
3. 通过 select …lock in share mode获取行的读锁后，如果当前事务在需要对该记录进行更新操作，则很有可能造成死锁。
4. 改变事务隔离级别。

### 如何处理死锁 #未优化

1. 通过innodblockwait_timeout来设置超时时间，一直等待直到超时。
2. 发起死锁检测，发现死锁之后，主动回滚死锁中的事务，不需要其他事务继续。

### InnoDB如何处理死锁 #未优化

innodb默认是使用设置死锁时间来让死锁超时的策略，默认innodblockwait_timeout设置的时长是50s。

### 有什么办法可以优化锁 #未优化

1. 使用较低的隔离级别设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突
2. 选择合理的事务大小，
3. 给记录显示加锁时，最好一次性请求足够级别的锁。列如，修改数据的话，最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁
4. 不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。
5. 尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响
6. 不要申请超过实际需要的锁级别
7. 数据查询的时候不是必要，不要使用加锁。MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能：MVCC只在committed read（读提交）和 repeatable read （可重复读）两种隔离级别
8. 对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。

### 主从架构的工作原理

整体上来说，复制有 3 个步骤： 

1. 主库将修改语句（ DDL、DCL、DML ）操作记录到二进制日志 bin log 中；
2. 从库将主库的 bin log 通过 I/O 线程拷贝到它的中继日志 relay log ；
3. 从库通过 SQL 线程重做中继日志中的事件（操作），修改从机上的数据。

![file://c:\users\admini~1\appdata\local\temp\tmpodtugz\1.png](https://figure-bed-1304788733.cos.ap-guangzhou.myqcloud.com/typora/202203031928916.png)

### 物理备份与逻辑备份的优缺点

- 物理备份：

  - 通过备份数据文件、控制文件、日志文件及服务器系统文件，把所有数据文件直接备到一个文件集合中。
  - 优点是备份速度快，恢复速度也很快，还能减少备份时出现脏数据的情况。
  - 缺点是需要占用大量磁盘空间，而且不能用于表级别的恢复。

- 逻辑备份：
  - 通过SQL命令将数据库中的“数据库对象（如表、索引、视图等）、用户数据和数据库参数”导出到文件中并进行备份，通常用于备份特定的对象或部分数据的情况下。
  - 优点是灵活性高，对于表级别、对象的备份和恢复非常方便。
  - 缺点是备份和恢复速度相对物理备份要慢一些，且数据类型、字符集等可能存在转换问题。
  - 在恢复逻辑备份的数据时，需要先建立好相对应的数据库结构，对全数据库恢复而言较为繁琐。

![image.png](https://s2.loli.net/2023/06/29/YgkX1Tudof2UeyS.png)

### 怎么用 XtraBackup 备份与恢复

1. **全量备份**

   ```shell
   innobackupex --defaults-file=/etc/my.cnf --socket=/var/lib/mysql/mysql.sock --user=root --password=123456 [bak_dir]
   ```

   该操作会在指定目录下生成一个名为当时备份操作时间的文件夹，备份好的数据都在其中；

2. **全量恢复**

   首先要停止服务；

   ```shell
   systemctl stop mysqld
   ```

   然后重做事务日志；

   ```shell
   innobackupex --apply-log [bak_dir] 
   ```

   接着恢复备份；

   ```shell
   innobackupex --defaults-file=/etc/my.cnf --copy-back
   ```

   最终重新启动服务即可。

   ```shell
   systemctl start mysqld
   ```

3. **增量备份**

   在全量备份的基础上进行增量操作。

   ```shell
   innobackupex --defaults-file=/etc/my.cnf --host=127.0.0.1 --user=root  --password=123456 --incremental --incremental-basedir=[bak_dir] [incre_dir]
   ```

4. **增量恢复**

   首先要停止服务；

   ```shell
   systemctl stop mysqld
   ```

   然后执行全量备份回滚操作；

   ```shell
   innobackupex --apply-log --redo-only [bak_dir]
   ```

   接着执行增量备份到全量备份回滚操作；

   ```shell
   # --redo-only 选项仅在回滚最新的增量备份时可去除
   innobackupex --apply-log [bak_dir] --incremental-dir=[incre_dir]
   ```

   然后执行增量备份恢复。

   ```shell
   innobackupex --defaults-file=/etc/my.cnf --copy-back [bak_dir]
   ```

   最终重新启动服务即可。

   ```shell
   systemctl start mysqld
   ```

### 简单介绍下MHA高可用架构

MHA 是 MySQL 的高可用解决方案之中的一种，能做到在<font color=red> **0 ~ 30** </font>秒之内，自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA 能在最大程度上保证数据的一致性，以达到真正意义上的高可用。

### 讲解一下MHA的架构

MHA 主要支持一主多从的架构，它要求一个复制集群中，最少有三台数据库服务器，用于搭建一主两从架构，即一台充当主库，一台从机充当备用主库，另外一台充当从库。

MHA 支持所有存储引擎，只要能主从复制的存储引擎它都支持。

MHA 由两部分组成：

1. MHA Manager （管理节点）
   - MHA Manager 能单独部署在一台独立机器上管理多个主从集群，也能部署在一台从库节点上。
   - 用于检测主库是否宕机。
   - 管理 MHA 服务，如启停、检查状态。
   - 手工转移故障。
   - 检查 MySQL 复制状况。

2. MHA Node （数据节点）
   - MHA Node 运行在每台 MySQL 服务器上。
   - 当主库出现故障时，它可以自动将"最新数据的从库"提升为新的主库，然后将所有其他从库重新指向新的主库。

整个故障转移过程对应用程序完全透明。

![file://c:\users\admini~1\appdata\local\temp\tmpl4ezg9\1.png](https://figure-bed-1304788733.cos.ap-guangzhou.myqcloud.com/typora/202203071920725.png)

### 讲讲MHA的工作原理

MHA 工作原理总结为如下：

1. 从宕机崩溃的主库保存二进制日志事件（binlog events）(数据节点操作)
2. 识别含有最新更新的从库；
3. 应用差异的中继日志（relay log）到其他的从库；
4. 应用从主库保存的二进制日志事件（binlog events）（管理节点操作）
5. 提升一个从库为新的主库；
6. 使其他的从库连接新的主库进行复制。

### 在MHA下如何保证连接稳定

使用自带脚本 master_ip_failover 或 keepalived 。

生产一般用前者。

### MHA有没有什么缺点

只要宕机过一次，就会结束 MHA 后台进程，需要重新配好宕机的机器与其他机器的主从关系，然后在管理节点的 MHA 配置文件添加宕机的信息，再回去重新运行 MHA 。

### 简单介绍一下Atlas是什么

Atlas 是一个基于 MySQL 协议开发的数据中间件，主要可以用于实现 MySQL 的读写分离，目前有超过**<font color=red> 50 </font>**家公司在生产环境中部署了 Atlas 。

Atlas 作为服务端与应用程序通讯，它实现了MySQL的客户端和服务端协议，同时作为客户端与MySQL通讯。

在后端数据库看来，Atlas 相当于连接它的客户端；在前端应用看来，Atlas 相当于一个数据库。

#### **Atlas的主要功能**

1. 读写分离；
2. 从库负载均衡；
3. IP过滤；
4. 自动分表；
5. DBA可平滑上下线DB；
6. 自动摘除宕机的DB。

<h1>缓存中间件</h1>

## Redis

### Redis 的优点有哪些？

1. **性能极高、高性能读写**

   Redis 能读的速度是<font color='red'> 110000 </font>次每秒，写的速度是<font color='red'> 81000 </font>次每秒。

2. **丰富的数据类型、多数据类型支持**

   Redis 支持 **String（字符串）、Hash（哈希），List（列表），Set（集合）还有 Zset（有序集合）**五种数据类型。

   随着 Redis 版本的更新，后面又支持了四种数据类型： **BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）**。

3. **丰富的特性**

   Redis 还支持 publish/subscribe、通知、key 过期等等特性。

除了以上优点之外，Redis 还支持**持久化**、支持**高可用**架构、支持**自定义虚拟内存**、支持**分布式分片集群**，且单线程**读写性能极高**。（redis6.0以前版本没有多线程）

### 介绍一下 Redis 的数据类型

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

![image.png](https://s2.loli.net/2023/07/31/1eQOiIalM3vt7HP.png)

1. **String（字符串）**

   最基本的数据类型，可存储字符串、整数或浮点值。

   String 的一个键对应一个值，一个值最大存储是 512 MB 。

   - **读写能力：**
     1. 可以对整个字符串或者字符串的一部分进行操作；
     2. 可以对整数或者浮点数进行自增或自减操作。

   - **应用场景：**

     1. 缓存对象；
     2. 常规计数；
     3. 分布式锁；
     4. 共享 session 信息；
     5. etc.

   - **内部实现：**

     String 数据结构底层内部通过 **SDS （简单动态字符串）**实现。

     相比于 C 语言的字符串，SDS 有以下优点：

     - **SDS 不仅可以保存文本数据，还可以保存二进制数据**。

       因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。

     - **SDS 获取字符串长度的时间复杂度是 O(1)**。

       因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。

     - **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。

       因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。

2. **Hash（哈希字典）**

   是一种键值对的集合，最接近 MySQL 表结构的一种类型。

   可以存储包含键值对的无序散列表。

   Hash 的单个键值对最大能存储约 512 MB 的内容。

   ```
   因为 Hash 使用字典结构存储数据，而每个键值对的值是一个 String 字符串对象。
   如上文所述，String 的最大限制是 512 MB。
   因此，单个键值对的内容大小不能超过这个限制。
   ```

   - **读写能力：**

     包含方法有添加、获取、删除单个元素。

   - **应用场景：**

     1. 缓存对象；
     2. 数据库缓存；
     3. 购物车；
     4. etc.

   - **内部实现：**

     Hash 数据类型底层内部通过**压缩列表**或**哈希表**实现。

     在 Redis 7.0 之后的版本中，通过 **listpack 紧凑数据结构**或**哈希表**实现。

     - **使用压缩列表实现时：**

       Hash 元素个数小于 **512** 个，且所有值小于 **64** 字节。

       ```
       此为默认情况，以上数值分别由下列参数配置：
       	元数个数：hash-max-ziplist-entries
       	所有值大小：hash-max-ziplist-value
       请具体情况具体分析。
       ```

     - **使用 listpack 实现时：**

       有两种可能：

       1. Hash 元素个数**小于等于** 32 个；
       2. 所有元素的字节大小都**小于等于** 64 字节。

     - **使用哈希表实现时：**

       1. 说明 Hash **元素个数**与**所有值**均不符合压缩列表的条件。
       2. 在 Redis 7.0 之后的版本中，说明 Hash 中的列表数量大于 8 。

3. **List（列表）**

   是一种有序的、可重复的数据类型。

   它通过链表存储字符串元素，链表上的每个节点都包含一个字符串。

   - **读写能力：**

     1. 对链表的两端进行push插入和pop移出操作，读取单个或多个元素；
     2. 根据值查找或删除元素。

   - **应用场景：**

     1. 消息队列

        ```
        有两个前提：
        1. 生产者需要自行实现全局唯一 ID ；
        2. 不能以消费组形式消费数据。
        ```

     2. etc.

   - **内部实现：**

     List 数据类型底层内部通过**双向链表**或**压缩列表**实现。

     在 Redis 3.2 之后只通过 **quicklist （优化的双向链表）** 实现。

     - **使用压缩列表实现时：**

       List 的元素个数**小于** 512 个，且每个元素的值都**小于** 64 字节。

       ```
       此为默认情况，以上数值分别由下列参数配置：
       	元数个数：list-max-ziplist-entries
       	所有值大小：list-max-ziplist-value
       请具体情况具体分析。
       ```

     - **使用双向链表实现时：**

       说明 List **元素个数**与**所有元素的大小**均不符合压缩列表的条件。

4. **Set（无序集合）**

   是一个不可重复的无序集合，并在无序合中存储字符串。

   - **读写能力：**

     1. 添加、获取、删除；
     2. 计算交集、并集、差集；
     3. etc.

   - **应用场景：**

     1. 聚合计算（并集、交集、差集）场景，

        比如点赞、共同关注、抽奖活动等。

     2. etc.

   - **内部实现：**

     Set 数据类型底层内部通过**哈希表**或**整数集合**实现。

     - **使用整数集合实现时：**

       集合中的元素都是整数，且元素个数**小于** 512 个。

       ```
       此为默认情况，以上数值由下列参数配置：
       	元数个数：set-maxintset-entries
       请具体情况具体分析。
       ```

     - **使用哈希表实现时：**

       说明 Set 数据类型中的数据不符合整数集合的条件。

5. **Zset（有序集合）**

   是一个不可重复的有序集合，并在有序集合中存储键值对。

   它类似于普通的集合（Set），但每个元素都关联着一个叫做分值（score）的浮点数。

   元素的排列顺序由分值的大小决定。

   - **读写能力：**

     1. 添加、获取、删除单个元素；
     2. 根据分值范围或成员来获取元素；
     3. 并集、交集、差集集合计算。

   - **应用场景：**

     1. **排序场景**

        比如排行榜、电话和姓名排序等。

     2. **带权重的任务队列**

        根据任务的优先级（分值）和到期时间进行任务调度。

     3. **数据统计**

        通过有序集合的范围操作，可以实现高效的数据统计功能。

   - **内部实现：**

     Zset 数据类型底层内部通过**压缩列表**或**跳表**实现。

     - **使用压缩列表实现时：**

       有序集合的元素个数**小于** 128 个，且每个元素的值**小于** 64 字节。

     - **使用跳表实现时：**

       说明 Zset 数据类型中的数据不符合压缩列表的条件。

Redis 后续版本又新支持四种数据类型，它们的应用场景如下：

- **BitMap 位图（2.2 版新增）**

  二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；

- **HyperLogLog 统计基数（2.8 版新增）**

  海量数据基数统计的场景，比如百万级网页 UV 计数等；

- **GEO 地理位置（3.2 版新增）**

  存储地理位置信息的场景，比如滴滴叫车；

- **Stream 消息队列（5.0 版新增）**

  相比于基于 List 类型实现的消息队列，有这两个特有的特性：

  1. 自动生成全局唯一消息ID；
  2. 支持以消费组形式消费数据。

### 讲一下 Redis 持久化

1. **RDB（全量）**

   基于快照的持久化，速度更快，但是可能会有数据丢失。

   一般用作全量备份、数据恢复和数据迁移的场景。

   Redis 主从复制也是依赖于 RDB 持久化功能，压缩比高，体积小比较省空间。

   - **执行过程**
     1. 生成一个子进程；
     2. 通过子进程将数据写入临时文件；
     3. 将临时文件替换原来的RDB文件，如默认的dump.rdb。

   - **操作方法**

     - 修改redis.conf中的参数

       ```shell
       # 旧版写法：
       # 900秒（15分钟）内有1个键更改，则启动快照保存
       save 900 1
       # 300秒（5分钟）内有10个键更改，则启动快照保存
       save 300 10
       # 60秒内有10000个键更改，则启动快照保存
       save 60 10000
       
       # 新版写法：
       # 多个条件写在一行语句中
       save 3600 1 300 100 60 10000
       ```

2. **AOF（增量）**

   基于记录写命令的持久化，类似 MySQL 的 binlog ，更安全，但不利于数据备份与迁移。

   - **执行过程**

     ![img](https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7-20230309232240301.png)

     1. 正常执行写命令；
     2. 记录 Redis 的写命令，将其追加到 appendonly.aof 文件末尾；
     3. 当 Redis 启动时，重新执行文件内的命令来恢复数据。

   - **操作方式**

     - AOF持久化的选项有三种模式

       1. 关闭（no）
       2. 每秒同步（everysec）
       3. 每个写命令同步（always）

     - 修改redis.conf中的参数

       ```shell
       appendonly yes			# 开启AOF持久化存储方式
       # appendfsync always	# 收到写命令后立即写入磁盘，效果最好
       # appendfsync everysec	# 每秒写入磁盘一次，可能会造成数据丢失
       # appendfsync no		# 由操作系统判断内存缓冲区大小，效果无法保证
       ```

3. **RDB 与 AOF 的区别**

   - RDB 执行速度更快，占用空间更少；
   - AOF 记录数据更完整，数据更安全。

4. **持久化的优先顺序**

   AOF => RDB

   1. 如果只配置了AOF，启动时将加载AOF文件恢复数据
   2. 如果只配置了RDB，启动时将加载dump.db文件恢复数据
   3. <font color='red'>如果同时配置了AOF与RDB，启动时只加载AOF文件恢复数据</font>

   P. S. dump.db 是 Redis 默认的自动备份方式。

5. **混合持久化**

   Redis 4.0 提出了**混合使用 AOF 日志和 RDB 内存快照**，也叫混合持久化。

   混合持久化在 **AOF 日志重写过程**中进行操作。

   此模式既保证了 Redis 重启速度，又降低数据丢失风险。

   - **执行过程**
     1. 生成子进程；
     2. 通过子进程将数据以 RDB 方式写入 AOF 文件中，此为前半部分；
     3. 将写命令记录在重写缓冲区；
     4. 将重写缓冲区的增量命令以 AOF 方式写入到 AOF 文件中，此为后半部分；
     5. 将新的 AOF 模式替换旧的 AOF 文件，此时持久化操作完成。

   ![img](https://cdn.xiaolincoding.com//mysql/other/f67379b60d151262753fec3b817b8617-20230309232312657.png)

   从执行过程可以看出，使用混合持久化之后，AOF 文件的**前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据**。

   - **混合持久化优点：**
     - 混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。
   - **混合持久化缺点：**
     - AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
     - 兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。

### 大致聊聊 Redis 的事务

- **三个阶段**

  Redis 的事务和关系型数据库不太一样，它的事务形式上分为三个阶段：

  1. **开启事务**（multi）
  2. **命令入队**（业务操作，将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面）
  3. **执行事务**（exec）或**取消事务**（discard）

- **三个特征**

  Redis 事务可以一次执行多条命令，并且具备以下3个特征：

  1. **单独的隔离操作**

     事务中的所有命令都会序列化、按顺序地执行。

     事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

  2. **没有隔离级别的概念**

     队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题。

  3. **不保证原子性**

     同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。

- **Redis 的ACID性质**

  在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的安全性。

  Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。

- **watch 和 unwatch**

  除了简单的事务操作之外，Redis 还支持监视事务中的键值变化，当事务中的键值被修改后，执行事务时会失败。Redis 通过 watch 和 unwatch 实现了这个功能。

  1. **watch**

     通过 `watch` 命令在事务执行之前监控多个 keys。

     倘若在 watch 之后有任何 key 的值发生变化，exec 命令执行的事务都将被放弃，同时返回 Null 应答以通知调用者事务执行失败。

     **watch命令，类似乐观锁**，事务提交时，如果 key 的值已被别的客户端改变，比如某个 list 已被别的客户端 push/pop 过了，整个事务队列都不会被执行。（当然也可以用 Redis 实现分布式锁来保证安全性，属于悲观锁）

  2. **unwatch**

     使用无参数的 `unwatch` 命令可以手动取消对所有键的监视。

     对于一些需要改动多个键的事务，有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。

     当值达不到要求时， 就可以使用 unwatch 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。



